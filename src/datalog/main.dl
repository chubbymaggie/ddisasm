//===- main.dl --------------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This is the main module of the datalog disassembler.
The disassembly has 3 main components:
 1- code_inference.dl
	 -code_inference_postprocess.dl
	 -cfg.dl
 2- symbolization.pl
     - use_def_analysis.dl
     - value_analysis.dl
     - data_access_analysis.dl
     - pointer_reatribution.dl

 3- function_inference.pl
     -intra_procedural_cfg_completeness.dl
     -no_return_analysis.dl
         -intra_procedural_SCC.dl

In addition there are several modules that consider special cases,
generic components and tables.

 Special cases:
  -relative_jump_tables.dl

 Generic components:
  -ordered_set.dl
  -empty_range.dl

 Tables:
  -float_operations.dl
  -jump_operations.dl
  -printable_chars.dl

This module:
- defines the input generated by the decoder
- defines a series of auxiliary predicates and basic facts that are used everywhere.
- defines some hard-code parameters of the analysis, such as the code and data sections
  explored.
*/

.symbol_type register

.number_type address
.number_type operand_code
.number_type operand_index

// tables with basic facts
#include "printable_chars.dl"
#include "jump_operations.dl"
#include "interrupt_operations.dl"

// Detection of relative jump tables
#include "relative_jump_tables.dl"

// Inference of instruction boundaries
#include "code_inference.dl"

// Performs literal-reference desambiguation
// and strings
#include "symbolization.dl"

// Inferece of function boundaries
#include "function_inference.dl"

// predicates for debugging and statistics
#include "debug_stats.dl"

/////////////////////////////////////////////////////////////
// Inputs generated by the decoder
/////////////////////////////////////////////////////////////

// metadata
.decl entry_point(ea:address)
.input entry_point

.decl symbol(ea:address,size:number,type:symbol,scope:symbol,sectionIndex:number,name:symbol)
.input symbol

.decl section(name:symbol,size:number,addr:address)
.input section

.decl relocation(ea:address,type:symbol,name:symbol,addend:number)
.input relocation

.decl binary_type(Type:symbol)
.input binary_type


//FIXME: add eh_frames

// instructions
.decl instruction(ea:address, size:number, prefix:symbol, opcode:symbol,
		  op1:operand_code, op2:operand_code, op3:operand_code, op4:operand_code)
.input instruction

.decl invalid_op_code(ea:address)
.input invalid_op_code

	
// three kinds of operators
.decl op_regdirect(code:operand_code,register_name:register)
.input op_regdirect

.decl op_immediate(code:operand_code,offset:number)
.input op_immediate

.decl op_indirect(code:operand_code,reg1:register, reg2:register, reg3:register,
		multiplier:number, offset:number, size_value:number)
.input op_indirect

//data from data sections
.decl data_byte(ea:address,value:number)
.input data_byte

.decl address_in_data(ea:address,value:number)

.input address_in_data


/////////////////////////////////////////////////////////////
// auxiliary definitions
/////////////////////////////////////////////////////////////

.decl instruction_get_operation(ea:address,operation:symbol) 

instruction_get_operation(EA,Operation):-
	instruction(EA,_,_,Operation,_,_,_,_).
	
.decl instruction_get_op(ea:address, index:number, operator:operand_code)

instruction_get_op(EA,Index,Op):-
	instruction(EA,_,_,_,Op1,Op2,Op3,Op4),
	(
	Op1!=0,
	Op=Op1,Index=1
	;
	Op2!=0,
	Op=Op2,Index=2
	;
	Op3!=0,
	Op=Op3,Index=3
	;
	Op4!=0,
	Op=Op4,Index=4
	).

.decl instruction_get_dest_op(ea:address,index:number,op:operand_code)

instruction_get_dest_op(EA,Index,Op):-
	instruction(EA,_,_,Operation,_,Op2,Op3,Op4),
	!read_only_operation(Operation),
	(
	Op4=0,
	Op3=0,
	Op2!=0,
	Op=Op2,
	Index=2
	;
	Op4=0,
	Op3!=0,
	Op=Op3,
	Index=3
	;
	Op4!=0,
	Op=Op4,
	Index=4
	).
instruction_get_dest_op(EA,1,Op):-
	instruction(EA,_,_,Operation,Op,0,0,0),
	one_op_write(Operation).

.decl instruction_get_src_op(ea:address,Index:operand_index,op:operand_code)

//when the dest is used as a source as well
instruction_get_src_op(EA,Index,Op2):-
	instruction(EA,_,_,_Operation,_,Op2,_,_),Op2!=0,
	Index=2,
	!mov(EA).
//	!read_only_operation(Operation).

instruction_get_src_op(EA,Index,Op):-
	(
	instruction(EA,_,_,_,Op,_,_,_),Op!=0,Index=1
	;
	instruction(EA,_,_,_,_,Op,Op3,_),Op!=0,Op3!=0,Index=2
	;
	instruction(EA,_,_,_,_,_,Op,Op4),Op!=0,Op4!=0,Index=3
	).
/////////////////////////////////////////////////////////////
// hard-coded facts
/////////////////////////////////////////////////////////////
.decl conditional_mov(EA:address)

conditional_mov(EA):-
	instruction_get_operation(EA,Operation),
	contains("CMOV",Operation).
	
.decl mov(EA:address)

mov(EA):-
	instruction_get_operation(EA,Operation),
	contains("MOV",Operation).	


.decl is_nop(EA:address)

is_nop(EA):-
    instruction_get_operation(EA,"NOP").

is_nop(EA):-
    instruction(EA,_,_,"XCHG",Op,Op,0,0),
    op_regdirect(Op,"AX").

.decl comparison_operation(Operation:symbol)

comparison_operation("CMP").
comparison_operation("TEST").

.decl read_only_operation(Operation:symbol)

read_only_operation("TEST").
read_only_operation("CMP").

.decl one_op_write(Operation:symbol)

one_op_write("INC").
one_op_write("DEC").

.decl null_reg(name:symbol)

null_reg("NullReg64").
null_reg("NullReg32").
null_reg("NullReg16").
null_reg("NullSReg").

.decl pointer_size(n:number) inline
pointer_size(8).

.decl data_section(name:symbol)

data_section(".rodata").
data_section(".data").
data_section(".bss").
data_section(".got").
data_section(".got.plt").
data_section(".init_array").
data_section(".fini_array").
data_section(".data.rel.ro").

.decl regular_data_section(name:symbol)

regular_data_section(".rodata").
regular_data_section(".data").
regular_data_section(".bss").

.decl code_section(name:symbol)

code_section(".text").
code_section(".plt").
code_section(".plt.got").
code_section(".fini").
code_section(".init").



/////////////////////////////////////////////////////////////
// inference of basic facts
/////////////////////////////////////////////////////////////


.decl next(n:address,m:address)

next(EA,EA+Size):-
	instruction(EA,Size,_,_,_,_,_,_).
	
.decl pc_relative_operand(src:address,index:number, dest:address)
.output pc_relative_operand

// pc_relative_operand(EA,Index,Dest):-
// 	pc_relative_operand_complete(EA,Index,Dest,_).

// .decl pc_relative_operand_complete(src:address,index:number, dest:address, size:number)

pc_relative_operand(EA,Index,EA_next+Offset):-
	instruction_get_op(EA, Index, Op),
        op_indirect(Op,NullSReg,"RIP",NullReg1,1,Offset,_),
	null_reg(NullSReg),
	null_reg(NullReg1),
	next(EA,EA_next).

.decl loop_operation(operation:symbol)

loop_operation("LOOP").
loop_operation("LOOPNE").
loop_operation("LOOPE").

.decl loop_prefix(prefix:symbol)

loop_prefix("REP").
loop_prefix("REPE").
loop_prefix("REPNE").

.decl instruction_has_loop_prefix(EA:address)

instruction_has_loop_prefix(EA):-
	instruction(EA,_,Prefix,_,_,_,_,_),
	loop_prefix(Prefix).

// JUMPS
.decl unconditional_jump(n:address)

unconditional_jump(EA):-
	instruction_get_operation(EA,"JMP").

.decl conditional_jump(src:address)

conditional_jump(EA):-
    instruction_get_operation(EA,Operation),
    jump_operation(Operation),
    Operation!="JMP".

// direct jumps
.decl direct_jump(src:address, dest:address)
.output direct_jump

direct_jump(EA,Dest):-
	instruction(EA,_,_,Operation,Op1,_,_,_),
	jump_operation(Operation),
	op_immediate(Op1,Dest).

direct_jump(EA,Dest):-
	instruction(EA,_,_,Operation,_,Op2,_,_),
	loop_operation(Operation),
	op_immediate(Op2,Dest).

direct_jump(EA,EA):-
	instruction_has_loop_prefix(EA).

// Special kinds of indirect jumps
// PC relative jumps
.decl pc_relative_jump(src:address, dest:address)
.output pc_relative_jump

pc_relative_jump(EA,Dest):-
	instruction_get_operation(EA,Operation),
	jump_operation(Operation),
	pc_relative_operand(EA,1,Dest).

	
// jump to the address of a register
// for now we do not compute anything about these
 .decl reg_jump(src:address)

reg_jump(EA):-
	instruction(EA,_,_,Operation,Op1,_,_,_),
	jump_operation(Operation),
	op_regdirect(Op1,_).
	
	
// indirect jump	
 .decl indirect_jump(src:address)

indirect_jump(EA):-
	instruction(EA,_,_,Operation,Op1,_,_,_),
	jump_operation(Operation),
	op_indirect(Op1,_,_,_, _,_,_),
	!pc_relative_jump(EA,_).

// CALLS
// direct calls
.decl direct_call(src:address, dest:address)
.output direct_call

direct_call(EA,Dest):-
	instruction(EA,_,_,"CALL",Op1,_,_,_),
	op_immediate(Op1,Dest).


.decl pc_relative_call(src:address,dest:address)
.output pc_relative_call

pc_relative_call(Src,Dest):-
	instruction_get_operation(Src,"CALL"),
	pc_relative_operand(Src,1,Dest).


// for now we do not compute anything about these
.decl reg_call(src:address)
.output reg_call

reg_call(EA):-
	instruction(EA,_,_,"CALL",Op1,_,_,_),
 	op_regdirect(Op1,_).

 .decl indirect_call(src:address)
// .output indirect_call

indirect_call(EA):-
	instruction(EA,_,_,"CALL",Op1,_,_,_),
 	op_indirect(Op1,_,_,_,_,_,_),
 	!pc_relative_jump(EA,_).

// Returns
.decl return(n:address)

return(EA):-
	instruction_get_operation(EA,"RET").

.decl halt(EA:address)

halt(EA):-
	instruction_get_operation(EA,"HLT").

halt(EA):-
	instruction_get_operation(EA,"UD2").

.decl ambiguous_symbol(name:symbol)
.output ambiguous_symbol

ambiguous_symbol(Name):-
        symbol(_,_,_,_,_,Name),
 	1< count :{symbol(_,_,_,_,_,Name)}.

// Function symbols
.decl function_symbol(ea:address,name:symbol)
.output function_symbol

function_symbol(EA,Name):-
	symbol(EA,_,"FUNC",_,_,Name).
	
////////////////////////////////////////////////////////////////////////////
// detect references  to libraries (calls to plt)
.decl plt_section(name:symbol)

plt_section(".plt").
plt_section(".plt.got").


.decl plt_entry(ea:address, function:symbol)
.output plt_entry

plt_entry(EA,Function):-
	plt_section(SecName),
	section(SecName,Size,Beg),
	EA<Beg+Size,
	EA>=Beg,
	pc_relative_jump(EA,Got_entry),
	relocation(Got_entry,_,Function,_).

.decl plt_data_reference(ea:address)

plt_data_reference(EA):-
    plt_entry(Dest,_),
	symbolic_data(EA,Dest).

//////////////////////////////////////////////////////////////////////////

.decl got_reference(EA:address,Index:number,Content:address)
.output got_reference

got_reference(EA,Index,Content):-
	pc_relative_operand(EA,Index,Dest),
	section(".got",Size,Beg),
	Dest>=Beg,
	Dest<Beg+Size,
	symbolic_data(Dest,Content).
//////////////////////////////////////////////////////////////////////////
// find the main function even if it does not have a symbol
//

.decl start_function(ea:address)
.output start_function

start_function(EA):-
	function_symbol(EA,"_start").
	
start_function(Start_location):-
	!function_symbol(Start_location,"_start"),
	entry_point(Start_location).


.decl main_function(ea:address)
.output main_function

main_function(EA):-
	function_symbol(EA,"main").

main_function(Main_location):-
	!function_symbol(Main_location,"main"),
	First_call= min EA:{
		    start_function(Entry),
		    instruction_get_operation(EA,"CALL"),
		    code(EA),
		    EA>=Entry},
	next(Prev,First_call),
        code(Prev),
	symbolic_code_operand_candidate(Prev,1,Main_location).

